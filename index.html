<!doctype html>
<html lang="en">
<head>

<script src='//libtl.com/sdk.js' data-zone='9771118' data-sdk='show_9771118'></script>


  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PEPE PARODY</title>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            bg1: '#0b1220',
            bg2: '#0e1624',
            card: 'rgba(255,255,255,0.06)',
            acc: '#22c55e',
            acc2: '#38bdf8',
            warn: '#f97316'
          },
          boxShadow: {
            soft: '0 10px 30px rgba(0,0,0,.25)'
          }
        }
      }
    }
  </script>

  <!-- Firebase (v10 modular CDN) -->
  <script type="module" crossorigin src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js"></script>
  <script type="module" crossorigin src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js"></script>

  <style>
    .glass{backdrop-filter: blur(10px)}
    .gradient-blob{position:absolute;inset:auto auto -80px -80px;width:320px;height:320px;filter:blur(60px);background:radial-gradient(circle at 30% 30%,#22c55e55,transparent 60%),radial-gradient(circle at 70% 40%,#38bdf855,transparent 60%)}
    .btn{display:inline-flex;align-items:center;gap:.5rem;padding:.6rem 1rem;border-radius:1rem}
    .tab-active{background:rgba(255,255,255,.12)}
    .hide{display:none}
    .banner{padding:.5rem 1rem;border-radius:.75rem;margin-bottom:.5rem}
    /* Custom input focus style */
    input:focus, select:focus {
        border-color: var(--acc); /* Using CSS variable for acc color */
    }
    /* Style for wdHint warning popup */
    .wd-hint-popup {
        background-color: rgba(249, 115, 22, 0.2); /* warn/20 */
        color: #f97316; /* warn color */
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        font-size: 0.75rem; /* text-xs */
        font-weight: 600; /* font-semibold */
        text-align: center;
        margin-top: 0.5rem;
        transition: opacity 0.3s ease-in-out;
        width: fit-content; /* Adjust width to content */
        max-width: 90%; /* Prevent overflow on small screens */
        position: absolute; /* Position absolutely to act as a popup */
        left: 50%;
        transform: translateX(-50%); /* Center horizontally */
        z-index: 1000; /* Ensure it's above other content */
        bottom: 1rem; /* Adjust as needed */
        pointer-events: none; /* Allow clicks to pass through */
    }
  </style>
</head>
<body class="min-h-dvh text-white bg-gradient-to-b from-bg1 to-bg2">
  <div class="relative mx-auto max-w-3xl p-4 sm:p-6 pb-24 space-y-4">
    <div id="firebaseBanner" class="hide banner bg-warn/20 text-warn text-sm">Warning</div>
    <div class="gradient-blob"></div>

    <!-- Top Bar -->
    <header class="flex items-center justify-between glass rounded-b-2xl border-b border-white/10 p-4 shadow-lg">
      <div class="flex items-center gap-3">
        <!-- Replaced 'P' div with an image for PEPE coin -->
        <div class="h-11 w-11 rounded-2xl bg-acc grid place-items-center text-black font-extrabold shadow-soft overflow-hidden">
            <img src="https://www.svgrepo.com/show/473727/pepe-coin.svg" alt="PEPE Coin" class="h-full w-full object-cover">
        </div>
        <div>
          <h1 class="text-2xl font-bold tracking-tight">PEPE PARODY</h1>
          <p class="text-xs text-white/70">_____</p>
        </div>
      </div>
      <!-- Theme button removed -->
    </header>

    <!-- PROFILE SCREEN (NOW CONTAINS EARN CONTENT) - Placed first as requested -->
    <section data-screen="profile" class="space-y-4">
      <!-- Profile Details -->
      <div class="glass rounded-3xl border border-white/10 p-5 bg-card shadow-soft">
        <h3 class="font-semibold mb-2">Profile Details</h3>
        <div class="mt-2 grid sm:grid-cols-2 gap-3">
          <div class="rounded-2xl bg-white/5 p-4 text-sm">
            <div class="opacity-70">Name</div>
            <div id="pfName" class="text-lg font-semibold">User</div>
          </div>
          <div class="rounded-2xl bg-white/5 p-4 text-sm">
            <div class="opacity-70">Telegram ID</div>
            <div id="pfId" class="text-lg font-semibold">–</div>
          </div>
          <div class="rounded-2xl bg-white/5 p-4 text-sm">
            <div class="opacity-70">Referred By</div>
            <div id="pfReferredBy" class="text-lg font-semibold">–</div>
          </div>
          <div class="rounded-2xl bg-white/5 p-4 text-sm">
            <div class="opacity-70">Total Referrals</div>
            <div id="pfRefCount" class="text-lg font-semibold">0</div>
          </div>
        </div>
      </div>

      <!-- Dev Fallback (moved from Earn, now at the top of the combined screen) -->
      <div id="devFallback" class="mt-4 hidden">
        <label class="text-xs text-white/70">Not inside Telegram? Enter a name to demo:</label>
        <div class="mt-2 flex gap-2">
          <input id="mockName" class="flex-1 rounded-xl px-3 py-2 bg-white/10 border border-white/10 focus:outline-none focus:border-acc" placeholder="Your name" />
          <button id="mockStart" class="btn bg-acc text-black font-semibold hover:opacity-90 active:scale-95 transition">Start</button>
        </div>
      </div>

      <!-- EARN ACTION BUTTONS (Daily, Task) - Reduced from previous, now part of Profile section -->
      <section class="grid grid-cols-2 gap-3">
        <button data-action="daily" class="action glass rounded-2xl border border-white/10 p-4 bg-card hover:bg-white/10 active:scale-95 transition">
          <div class="text-2xl font-extrabold">+50</div> <!-- Updated Daily Reward here -->
          <div class="text-xs text-white/70">Daily Check‑in</div>
        </button>
        <button data-action="task" data-nav="tasks" class="glass rounded-2xl border border-white/10 p-4 bg-card hover:bg-white/10 active:scale-95 transition">
          <div class="text-2xl font-extrabold">→</div>
          <div class="text-xs text-white/70">Go to Tasks</div>
        </button>
      </section>

      <!-- Quick Referral - Formerly part of Earn section, with button placement updated -->
      <section class="glass rounded-3xl border border-white/10 p-5 bg-card shadow-soft">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h3 class="font-semibold">Refer & Earn</h3>
            <p class="text-xs text-white/70">Invite friends and get <span class="font-semibold">+200 coins</span> for each new user.</p>
          </div>
          <div class="text-right text-xs opacity-75">
            <div>Referrals: <span id="refCount">0</span></div>
          </div>
        </div>
        <div class="mt-2 space-y-2">
          <input id="refLink" readonly class="w-full rounded-xl px-3 py-2 bg-white/10 border border-white/10 text-xs focus:outline-none" />
          <div class="flex gap-2">
            <button id="copyRef" class="btn flex-1 bg-acc text-black font-semibold hover:opacity-90 active:scale-95 transition">Copy Link</button>
            <button id="shareRef" class="btn flex-1 bg-acc2 text-black font-semibold hover:opacity-90 active:scale-95 transition">Share</button>
          </div>
        </div>
      </section>
    </section>

    <!-- TASKS SCREEN -->
    <section data-screen="tasks" class="space-y-4 hide">
      <div class="glass rounded-3xl border border-white/10 p-5 bg-card shadow-soft">
        <h3 class="font-semibold mb-2">Tasks</h3>
        <p class="text-xs text-white/70">Complete tasks to earn coins. (One‑time claim each)</p>
        <div id="taskList" class="mt-3 grid gap-3"></div>
      </div>
    </section>

    <!-- WALLET SCREEN (Updated to include Withdrawal) -->
    <section data-screen="wallet" class="space-y-4 hide">
      <div class="glass rounded-3xl border border-white/10 p-5 bg-card shadow-soft">
        <div id="walletOverview">
            <h3 class="font-semibold mb-2">Wallet Overview</h3>
            <div class="mt-2 grid grid-cols-2 gap-3">
              <div class="rounded-2xl bg-white/5 p-4">
                <div class="text-xs opacity-70">Balance</div>
                <div id="walletBalance" class="text-3xl font-black">0</div>
              </div>
              <div class="rounded-2xl bg-white/5 p-4">
                <div class="text-xs opacity-70">Total Referrals</div>
                <div id="walletRefs" class="text-3xl font-black">0</div>
              </div>
            </div>
            <div class="mt-3 flex gap-2">
              <button id="showWithdrawForm" class="btn bg-acc text-black font-semibold hover:bg-acc/90 active:scale-95 transition">Withdraw Funds</button>
            </div>
        </div>

        <!-- WITHDRAWAL FORM (moved here, updated for Binance UID) -->
        <div id="withdrawForm" class="space-y-4 hide">
            <h3 class="font-semibold mb-2">Withdrawal Request</h3>
            <p class="text-xs text-white/70">Minimum withdraw: <span id="minWd">100</span> coins</p>
            <div class="grid sm:grid-cols-2 gap-3 mt-3">
              <div class="space-y-2">
                <label for="wdAmount" class="text-xs text-white/70">Amount</label>
                <input id="wdAmount" type="number" class="w-full rounded-xl px-3 py-2 bg-white/10 border border-white/10 focus:outline-none focus:border-acc" placeholder="e.g., 200" />
              </div>
              <div class="space-y-2">
                <label for="wdAddress" class="text-xs text-white/70">Binance UID</label>
                <input id="wdAddress" class="w-full rounded-xl px-3 py-2 bg-white/10 border border-white/10 focus:outline-none focus:border-acc" placeholder="Please enter your uid" />
              </div>
            </div>
            <div class="mt-3 flex gap-2 items-center">
              <button id="submitWithdraw" class="btn bg-acc text-black font-semibold hover:bg-acc/90 active:scale-95 transition">Submit Request</button>
              <button id="hideWithdrawForm" class="btn bg-white/10 text-white font-semibold hover:bg-white/20 active:scale-95 transition">Back to Wallet</button>
            </div>
            <!-- wdHint moved outside the flex container for popup styling -->
            <div class="flex justify-center">
                <span id="wdHint" class="opacity-0 wd-hint-popup"></span>
            </div>
        </div>
      </div>

      <div class="glass rounded-3xl border border-white/10 p-5 bg-card shadow-soft">
        <div class="flex items-center justify-between">
          <h3 class="font-semibold">My Withdrawal History</h3>
          <span class="text-xs opacity-70">Completed: <span id="completedWdCount">0</span></span>
        </div>
        <ul id="wdList" class="mt-3 space-y-2 text-sm max-h-64 overflow-auto pr-1"></ul>
      </div>
      <!-- Activity History section removed -->
    </section>

    <!-- Admin Panel (Moved to main content area, next to Wallet section) -->
    <section id="adminPanel" class="hidden glass rounded-3xl border border-white/10 p-5 bg-black/40 shadow-soft">
      <div class="flex items-center justify-between">
        <h3 class="font-semibold">Admin Panel</h3>
        <span class="text-xs text-white/60" id="adminHint"></span>
      </div>
      <div class="grid sm:grid-cols-3 gap-3 mt-3">
        <div class="space-y-2">
          <label for="setBalance" class="text-xs text-white/70">Set Balance</label>
          <div class="flex gap-2">
            <input id="setBalance" type="number" class="flex-1 rounded-xl px-3 py-2 bg-white/10 border border-white/10 focus:outline-none focus:border-acc" placeholder="e.g., 500" />
            <button id="applySet" class="btn bg-acc text-black font-semibold hover:opacity-90 active:scale-95 transition">Apply</button>
          </div>
        </div>
        <div class="space-y-2">
          <label for="adjustBalance" class="text-xs text-white/70">Adjust Balance (+/−)</label>
          <div class="flex gap-2">
            <input id="adjustBalance" type="number" class="flex-1 rounded-xl px-3 py-2 bg-white/10 border border-white/10 focus:outline-none focus:border-acc" placeholder="e.g., +25 or -10" />
            <button id="applyAdjust" class="btn bg-acc2 text-black font-semibold hover:opacity-90 active:scale-95 transition">Update</button>
          </div>
        </div>
        <div class="space-y-2">
          <label class="text-xs text-white/70">Data Actions</label>
          <div class="flex gap-2">
            <button id="resetUser" class="btn bg-white/10 hover:bg-white/20 active:scale-95 transition">Reset user</button>
            <button id="exportData" class="btn bg-white/10 hover:bg-white/20 active:scale-95 transition">Export JSON</button>
          </div>
        </div>
      </div>
    </section>

    <footer class="pt-2 pb-8 text-center text-xs text-white/50">© <span id="year"></span> PEPE BOT</footer>
  </div>

  <!-- Bottom Nav -->
  <nav class="fixed bottom-0 inset-x-0 mx-auto max-w-3xl bg-white/5 backdrop-blur border-t border-white/10 p-2 rounded-t-2xl shadow-lg">
    <div class="grid grid-cols-3 gap-2">
      <button data-nav="profile" class="btn tab-active font-semibold hover:bg-white/10 transition">Profile</button>
      <button data-nav="tasks" class="btn font-semibold hover:bg-white/10 transition">Tasks</button>
      <button data-nav="wallet" class="btn font-semibold hover:bg-white/10 transition">Wallet</button>
    </div>
  </nav>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, serverTimestamp,
      runTransaction, collection, addDoc, query, orderBy, onSnapshot
    } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js';

    // ================== CONFIG ==================
    // IMPORTANT: replace these placeholders with your actual Firebase project values.
    // If you keep placeholders or your Firestore rules require authentication, the app
    // will gracefully fall back to **local-only** mode (localStorage) and show a banner.
    // For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyANkFuPPFthsfrWNPwy6_vnFNhPJkPI5ew",
  authDomain: "money-tree-bot.firebaseapp.com",
  projectId: "money-tree-bot",
  storageBucket: "money-tree-bot.firebasestorage.app",
  messagingSenderId: "493331421972",
  appId: "1:493331421972:web:28227bfb312680c7c84001",
  measurementId: "G-38NSJXXG66"
};

    // NEW: Telegram Bot API Key - Keep this HIGHLY confidential!
    // For production, this should ONLY be stored and used on your backend server.
    const TELEGRAM_BOT_TOKEN = "7633393855:AAFeu07OuhX5l5bdcqgvP-chsF7E2zCtHbU"; // <<<<<<<<<<<< Add your bot token here

    const REFERRAL_BONUS = 200;
    const DAILY_REWARD = 50;
    const MIN_WITHDRAW = 1000;
    // Replace with actual numeric Telegram User IDs for your administrators
    const ADMIN_IDS = ["5146589219"]; // <<<<<<<<<<<< Add your Telegram User IDs here (as numbers)

    const q = new URLSearchParams(location.search);
    const isAdminQuery = q.get('admin') === '1';

    const els = {
      firebaseBanner: document.getElementById('firebaseBanner'),
      devFallback: document.getElementById('devFallback'),
      mockName: document.getElementById('mockName'),
      mockStart: document.getElementById('mockStart'),
      year: document.getElementById('year'),
      refLink: document.getElementById('refLink'),
      copyRef: document.getElementById('copyRef'),
      shareRef: document.getElementById('shareRef'),
      refCount: document.getElementById('refCount'),
      // Wallet
      walletOverview: document.getElementById('walletOverview'),
      withdrawForm: document.getElementById('withdrawForm'),
      showWithdrawForm: document.getElementById('showWithdrawForm'),
      hideWithdrawForm: document.getElementById('hideWithdrawForm'),
      walletBalance: document.getElementById('walletBalance'),
      walletRefs: document.getElementById('walletRefs'),
      wdList: document.getElementById('wdList'),
      completedWdCount: document.getElementById('completedWdCount'),
      // Withdraw (Inputs)
      minWd: document.getElementById('minWd'),
      wdAmount: document.getElementById('wdAmount'),
      wdAddress: document.getElementById('wdAddress'),
      submitWithdraw: document.getElementById('submitWithdraw'),
      wdHint: document.getElementById('wdHint'),
      // Profile
      pfName: document.getElementById('pfName'),
      pfId: document.getElementById('pfId'),
      pfReferredBy: document.getElementById('pfReferredBy'),
      pfRefCount: document.getElementById('pfRefCount'),
      // Admin
      adminPanel: document.getElementById('adminPanel'),
      adminHint: document.getElementById('adminHint'),
      setBalance: document.getElementById('setBalance'),
      applySet: document.getElementById('applySet'),
      adjustBalance: document.getElementById('adjustBalance'),
      applyAdjust: document.getElementById('applyAdjust'),
      resetUser: document.getElementById('resetUser'),
      exportData: document.getElementById('exportData'),
      // Tasks
      taskList: document.getElementById('taskList')
    };

    // Local state used only for UI helpers
    const state = { userId: null, name: 'User', lastDaily: null, firebaseEnabled: true };

    function formatTime(ts){ return new Date(ts).toLocaleString(); }
    function setRefLink(){
      const link = `${location.origin}${location.pathname}?ref=${state.userId}`;
      if(els.refLink) els.refLink.value = link;
    }

    // Function to show transient hint/warning message as a popup
    function showWdHint(message) {
        if (!els.wdHint) return;
        els.wdHint.textContent = message;
        els.wdHint.classList.remove('opacity-0'); // Make visible
        els.wdHint.classList.add('opacity-100');

        setTimeout(() => {
            els.wdHint.classList.remove('opacity-100'); // Start fade out
            els.wdHint.classList.add('opacity-0');
            // Optionally clear text after fade out
            setTimeout(() => {
                els.wdHint.textContent = '';
            }, 300); // Should match transition duration
        }, 3000); // Message visible for 3 seconds
    }

    function isPlaceholderConfig(cfg){
      if(!cfg) return true;
      return String(cfg.apiKey||'').includes('YOUR_') || String(cfg.projectId||'').includes('YOUR_');
    }

    // ----------------- LocalStorage fallback implementation -----------------
    function storageKey(uid){ return `pepebot:user:${uid}`; }
    function loadLocalUser(uid){
      try{ const raw = localStorage.getItem(storageKey(uid)); return raw ? JSON.parse(raw) : null; }catch{ return null; }
    }
    function saveLocalUser(uid, data){ try{ localStorage.setItem(storageKey(uid), JSON.stringify(data)); }catch(e){ console.error('local save failed',e); } }

    async function ensureUserLocal(uid, name){
      let u = loadLocalUser(uid);
      if(!u){
        u = {
          name: name||'User',
          balance: 0,
          createdAt: Date.now(),
          lastDaily: null,
          referredBy: null,
          referralBonusClaimed: false,
          referrals: 0,
          tasksCompleted: [],
          activities: [], // Keep activities for internal logging, even if not displayed
          withdrawals: []
        };
        u.activities.push({ text: 'First login — balance starts at 0', ts: Date.now() });
        saveLocalUser(uid,u);
      }
      return u;
    }

    async function addActivityLocal(uid, text){
      const u = loadLocalUser(uid) || await ensureUserLocal(uid, state.name);
      u.activities = u.activities || [];
      u.activities.push({ text, ts: Date.now() });
      saveLocalUser(uid,u);
      renderFromLocal(uid); // Re-render to update lists (primarily withdrawals)
    }

    async function addBalanceLocal(uid, delta, reason){
      const u = loadLocalUser(uid) || await ensureUserLocal(uid, state.name);
      u.balance = Math.max(0,(u.balance||0) + delta);
      saveLocalUser(uid,u);
      await addActivityLocal(uid, `${reason} ${delta>=0?'+':''}${delta} coins`);
    }

    async function tryDailyLocal(uid){
      const u = loadLocalUser(uid) || await ensureUserLocal(uid, state.name);
      const last = u.lastDaily ? new Date(u.lastDaily) : null;
      const now = new Date();
      if(last && now.toDateString() === last.toDateString()) return false;
      u.lastDaily = now.toISOString();
      saveLocalUser(uid,u);
      return true;
    }

    async function applyReferralLocal(uid, inviterId){
      if(!inviterId || inviterId === uid) return;
      const u = loadLocalUser(uid) || await ensureUserLocal(uid, state.name);
      if(u.referralBonusClaimed) return;
      u.referralBonusClaimed = true;
      u.referredBy = inviterId;
      saveLocalUser(uid,u);

      const inv = loadLocalUser(inviterId) || await ensureUserLocal(inviterId, 'User');
      inv.balance = (inv.balance||0) + REFERRAL_BONUS;
      inv.referrals = (inv.referrals||0) + 1;
      inv.activities = inv.activities || [];
      inv.activities.push({ text: `Referral bonus +${REFERRAL_BONUS} coins`, ts: Date.now() });
      saveLocalUser(inviterId, inv);

      await addActivityLocal(uid, `Referral link used from ${inviterId}`);
    }

    function renderFromLocal(uid){
      const u = loadLocalUser(uid) || { name: state.name, balance:0, activities:[], referrals:0, tasksCompleted:[], withdrawals:[] };
      // Profile details and referral count
      if(els.pfName) els.pfName.textContent = u.name || 'User';
      if(els.pfId) els.pfId.textContent = uid;
      if(els.pfReferredBy) els.pfReferredBy.textContent = u.referredBy || '–';
      if(els.pfRefCount) els.pfRefCount.textContent = u.referrals ?? 0;
      if(els.refCount) els.refCount.textContent = u.referrals ?? 0; // For Refer & Earn section
      setRefLink(); // Updates the refLink input

      // Wallet related displays
      if(els.walletBalance) els.walletBalance.textContent = u.balance ?? 0;
      if(els.walletRefs) els.walletRefs.textContent = u.referrals ?? 0;

      // withdrawals (for Wallet screen)
      if(els.wdList){
        els.wdList.innerHTML = '';
        let completedCount = 0;
        (u.withdrawals||[]).slice().reverse().forEach(it=>{
          const li = document.createElement('li');
          li.className = 'flex items-center justify-between bg-white/5 rounded-xl px-3 py-2';
          // Ensure 'method' is always set, even if it's 'undefined' from old local data
          const methodDisplay = it.method || 'Binance UID';
          li.innerHTML = `<span>${it.amount} • ${methodDisplay} • ${it.address}</span><span class="text-xs ${it.status==='rejected'?'text-red-400': it.status==='approved'?'text-green-400':'text-white/70'}">${it.status}</span>`;
          els.wdList.appendChild(li);
          if (it.status === 'approved') {
            completedCount++;
          }
        });
        if (els.completedWdCount) els.completedWdCount.textContent = completedCount;
      }

      // tasks rendering
      renderTasks(u.tasksCompleted||[]);
    }

    // helper to detect permission errors
    function isPermissionDenied(err){
      if(!err) return false;
      const msg = String(err.message||err).toLowerCase();
      const code = (err.code||'').toString();
      return code.includes('permission') || msg.includes('permission') || msg.includes('denied');
    }

    // ----------------- Firebase wrappers -----------------
    let app;
    let db;

    async function initFirebaseIfPossible(){
      if(isPlaceholderConfig(firebaseConfig)){
        state.firebaseEnabled = false;
        showFirebaseBanner('Firebase config contains placeholders. Running in local-only mode. Replace firebaseConfig to enable cloud features.');
        return;
      }

      try{
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        state.firebaseEnabled = true;
      } catch(err){
        console.warn('Firebase init failed:', err);
        state.firebaseEnabled = false;
        showFirebaseBanner('Firebase initialization failed — running in local-only mode. Check console for details.');
      }
    }

    // Firebase implementations (attempt, but fallback to local on permission errors)
    async function ensureUserFirebase(uid, name){
      try{
        const d = doc(db,'users',String(uid));
        const snap = await getDoc(d);
        if(!snap.exists()){
          await setDoc(d,{
            name: name || 'User',
            balance: 0,
            createdAt: serverTimestamp(),
            lastDaily: null,
            referredBy: null,
            referralBonusClaimed: false,
            referrals: 0,
            tasksCompleted: []
          });
          await addDoc(collection(db,'users',String(uid),'activities'),{ text: 'First login — balance starts at 0', ts: Date.now() });
        }
        const fresh = await getDoc(d);
        return fresh.data();
      } catch(err){
        if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied — falling back to local storage.'); return ensureUserLocal(uid,name); }
        throw err;
      }
    }

    async function addActivityFirebase(uid, text){
      try{ await addDoc(collection(db,'users',String(uid),'activities'),{ text, ts: Date.now() }); }
      catch(err){ if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied — falling back to local storage.'); return addActivityLocal(uid,text); } throw err; }
    }

    async function addBalanceFirebase(uid, delta, reason){
      try{
        await runTransaction(db, async (tx)=>{
          const d = doc(db,'users',String(uid));
          const snap = await tx.get(d);
          if(!snap.exists()) throw new Error('user not found');
          const cur = snap.data().balance || 0;
          const next = Math.max(0, cur + delta);
          tx.update(d, { balance: next });
        });
        await addActivityFirebase(uid, `${reason} ${delta>=0?'+':''}${delta} coins`);
      } catch(err){ if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied — falling back to local storage.'); return addBalanceLocal(uid,delta,reason); } throw err; }
    }

    async function tryDailyFirebase(uid){
      try{
        return await runTransaction(db, async (tx)=>{
          const d = doc(db,'users',String(uid));
          const snap = await tx.get(d);
          const data = snap.data();
          const last = data.lastDaily ? new Date(data.lastDaily.toDate()) : null;
          const now = new Date();
          if(last && now.toDateString() === last.toDateString()){
            return false;
          }
          tx.update(d,{ lastDaily: now });
          return true;
        });
      } catch(err){ if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied — falling back to local storage.'); return tryDailyLocal(uid); } throw err; }
    }

    async function applyReferralIfNew(uid, inviterId){
      if(!inviterId || inviterId===uid) return;
      if(!state.firebaseEnabled) return applyReferralLocal(uid, inviterId);
      try{
        await runTransaction(db, async (tx)=>{
          const selfRef = doc(db,'users',String(uid));
          const inviterRef = doc(db,'users',String(inviterId));
          const selfSnap = await tx.get(selfRef);
          if(!selfSnap.exists()) throw new Error('self missing');
          const self = selfSnap.data();
          if(self.referralBonusClaimed) return; // already processed
          tx.update(selfRef,{ referredBy: inviterId, referralBonusClaimed: true });

          const inviterSnap = await tx.get(inviterRef);
          if(inviterSnap.exists()){
            const inv = inviterSnap.data();
            const newBal = (inv.balance||0) + REFERRAL_BONUS;
            const newCount = (inv.referrals||0) + 1;
            tx.update(inviterRef,{ balance: newBal, referrals: newCount });
          }
        });
        await addActivityFirebase(uid, `Referral link used from ${inviterId}`);
        await addActivityFirebase(inviterId, `Referral bonus +${REFERRAL_BONUS} coins`);
      } catch(err){ if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied — falling back to local storage.'); return applyReferralLocal(uid, inviterId); } throw err; }
    }

    // Subscriptions – if Firebase available use realtime listeners, otherwise render from local
    async function subscribeUI(uid){
      if(state.firebaseEnabled && db){
        try{
          const d = doc(db,'users',String(uid));
          onSnapshot(d,(snap)=>{
            if(!snap.exists()) return;
            const data = snap.data();
            const bal = data.balance ?? 0;
            // Update Profile displays
            if(els.pfName) els.pfName.textContent = data.name || 'User';
            if(els.pfId) els.pfId.textContent = uid;
            if(els.pfReferredBy) els.pfReferredBy.textContent = data.referredBy || '–';
            if(els.pfRefCount) els.pfRefCount.textContent = data.referrals ?? 0;
            if(els.refCount) els.refCount.textContent = data.referrals ?? 0;
            state.lastDaily = data.lastDaily ? data.lastDaily.toDate() : null;
            setRefLink();

            // Update Wallet displays
            if(els.walletBalance) els.walletBalance.textContent = bal;
            if(els.walletRefs) els.walletRefs.textContent = data.referrals ?? 0;
          });

          const wq = query(collection(db,'users',String(uid),'withdrawals'), orderBy('createdAt','desc'));
          onSnapshot(wq,(qs)=>{
            if(els.wdList) els.wdList.innerHTML = '';
            let completedCount = 0;
            qs.forEach(docSnap=>{
              const it = docSnap.data();
              const li = document.createElement('li');
              li.className = 'flex items-center justify-between bg-white/5 rounded-xl px-3 py-2';
              const methodDisplay = it.method || 'Binance UID';
              li.innerHTML = `<span>${it.amount} • ${methodDisplay} • ${it.address}</span><span class="text-xs ${it.status==='rejected'?'text-red-400': it.status==='approved'?'text-green-400':'text-white/70'}">${it.status}</span>`;
              if(els.wdList) els.wdList.appendChild(li);
              if (it.status === 'approved') {
                completedCount++;
              }
            });
            if (els.completedWdCount) els.completedWdCount.textContent = completedCount;
          });
        } catch(err){
          if(isPermissionDenied(err)){
            switchToLocal('Firestore permission denied while subscribing — falling back to local storage.');
            renderFromLocal(uid);
          } else throw err;
        }
      } else {
        // fallback to local rendering if Firebase is not enabled
        renderFromLocal(uid);
      }
    }

    // ----------------- Common wrappers that choose Firebase or Local -----------------
    async function ensureUser(uid, name){
      if(state.firebaseEnabled && db) return ensureUserFirebase(uid,name);
      return ensureUserLocal(uid,name);
    }
    async function addActivity(uid, text){ if(state.firebaseEnabled && db) return addActivityFirebase(uid,text); return addActivityLocal(uid,text); }
    async function addBalance(uid, delta, reason){ if(state.firebaseEnabled && db) return addBalanceFirebase(uid,delta,reason); return addBalanceLocal(uid,delta,reason); }
    async function tryDaily(uid){ if(state.firebaseEnabled && db) return tryDailyFirebase(uid); return tryDailyLocal(uid); }

    // ----------------- Utility: switch to local mode on permission error -----------------
    function switchToLocal(message){
      state.firebaseEnabled = false;
      showFirebaseBanner(message + ' — App will continue in local-only mode.');
      console.warn('Switching to local mode:', message);
    }

    // ===== Tasks (same as before) =====
    const TASKS = [
      { id:'join_channel', title:'Join our Telegram Channel', reward: 250 },
      { id:'follow_twitter', title:'Follow X/Twitter', reward: 300 },
      { id:'invite_friend', title:'Invite a friend', reward: 200 },
      { id:'watch_video', title:'Watch the reference video', reward: 35 }
    ];
    function watchAd() {
            if (typeof show_9771118 === 'function') {
                show_9771118().then(() => {
                    const increment = firebase.firestore.FieldValue.increment;
                    userDocRef.update({ watchedAds: increment(1), earnedPoints: increment(0.50) }).catch(err => console.error("Error:", err));
                });
            }
}

    
    function renderTasks(completed=[]){
      if(!els.taskList) return;
      els.taskList.innerHTML = '';
      TASKS.forEach(t=>{
        const done = completed.includes(t.id);
        const card = document.createElement('div');
        card.className = 'flex items-center justify-between rounded-2xl bg-white/5 p-4';
        card.innerHTML = `<div><div class='font-semibold'>${t.title}</div><div class='text-xs opacity-70'>Reward: +${t.reward} coins</div></div>
          <button data-task='${t.id}' class='btn ${done?'bg-white/10 cursor-not-allowed opacity-60':'bg-acc text-black font-semibold hover:opacity-90 active:scale-95 transition'}'>${done?'Completed':'Claim'}</button>`;
        els.taskList.appendChild(card);
      })
    }

    async function handleTaskClaim(uid, taskId){
      if(state.firebaseEnabled && db){
        try{
          await runTransaction(db, async (tx)=>{
            const d = doc(db,'users',String(uid));
            const snap = await tx.get(d);
            const data = snap.data();
            const completed = data.tasksCompleted || [];
            const task = TASKS.find(t=>t.id===taskId);
            if(!task) throw new Error('task');
            if(completed.includes(taskId)) return; // already claimed
            completed.push(taskId);
            const nextBal = (data.balance||0) + task.reward;
            tx.update(d,{ tasksCompleted: completed, balance: nextBal });
          });
          await addActivity(uid, `Task '${taskId}' +${TASKS.find(t=>t.id===taskId).reward} coins`);
        } catch(err){ if(isPermissionDenied(err)){ switchToLocal('Firestore permission denied while claiming task.'); return handleTaskClaimLocal(uid,taskId); } else throw err; }
      } else {
        return handleTaskClaimLocal(uid,taskId);
      }
    }

    async function handleTaskClaimLocal(uid, taskId){
      const u = loadLocalUser(uid) || await ensureUserLocal(uid, state.name);
      const completed = u.tasksCompleted || [];
      const task = TASKS.find(t=>t.id===taskId);
      if(!task) throw new Error('task');
      if(completed.includes(taskId)) return;
      completed.push(taskId);
      u.tasksCompleted = completed;
      u.balance = (u.balance||0) + task.reward;
      saveLocalUser(uid,u);
      await addActivityLocal(uid, `Task '${taskId}' +${task.reward} coins`);
    }

    // ==== Telegram or Fallback detection and bootstrap ====
    async function initTelegramOrFallback(){
      const tg = window.Telegram && window.Telegram.WebApp;
      if (tg && tg.initDataUnsafe){
        tg.ready();
        const user = tg.initDataUnsafe.user || {};
        state.userId = user.id || 'guest';
        state.name = [user.first_name, user.last_name].filter(Boolean).join(' ') || user.username || 'User';

        // Initialize Firebase if possible
        await initFirebaseIfPossible(); // This sets state.firebaseEnabled and initializes db

        bootstrap(); // Proceed with bootstrap
      } else {
        els.devFallback.classList.remove('hidden');
        els.mockStart.addEventListener('click', ()=>{
          state.userId = 'guest';
          state.name = els.mockName.value || 'Guest';
          bootstrap();
        }, { once:true });
      }
    }

    async function bootstrap(){
      const inviter = q.get('ref');
      const me = await ensureUser(state.userId, state.name);
      renderTasks(me.tasksCompleted || []);
      subscribeUI(state.userId);
      showAdminIfAllowed(); // This is called here after state.userId is set
      if(inviter){ await applyReferralIfNew(state.userId, inviter); }
    }

    // ==== UI Actions ====
    function bindActions(){
      // Navigation
      const screens = Array.from(document.querySelectorAll('[data-screen]'));
      const navBtns = Array.from(document.querySelectorAll('nav [data-nav]'));
      function goto(tab){
        screens.forEach(s=> s.classList.toggle('hide', s.getAttribute('data-screen')!==tab));
        navBtns.forEach(b=> b.classList.toggle('tab-active', b.getAttribute('data-nav')===tab));
        // Special handling for wallet screen to ensure correct sub-view
        if (tab === 'wallet') {
            if (els.walletOverview) els.walletOverview.classList.remove('hide');
            if (els.withdrawForm) els.withdrawForm.classList.add('hide');
        }
      }
      // Set 'profile' as the initial active tab
      goto('profile');

      navBtns.forEach(b=> b.addEventListener('click', ()=> goto(b.getAttribute('data-nav')) ));
      document.querySelectorAll('[data-nav]').forEach(b=>{
        // Ensure this only applies to buttons not in the main nav or specifically the 'showWithdrawForm' button
        if(!b.closest('nav') && b.id !== 'showWithdrawForm') {
             b.addEventListener('click', ()=> goto(b.getAttribute('data-nav')) );
        }
      });

      // Wallet sub-navigation (show/hide withdraw form)
      if (els.showWithdrawForm) {
          els.showWithdrawForm.addEventListener('click', () => {
              if (els.walletOverview) els.walletOverview.classList.add('hide');
              if (els.withdrawForm) els.withdrawForm.classList.remove('hide');
              // Clear hint when showing form
              showWdHint('');
          });
      }
      if (els.hideWithdrawForm) {
          els.hideWithdrawForm.addEventListener('click', () => {
              if (els.walletOverview) els.walletOverview.classList.remove('hide');
              if (els.withdrawForm) els.withdrawForm.classList.add('hide');
              // Clear hint when hiding form
              showWdHint('');
          });
      }

      // Earn actions (now within Profile screen)
      document.querySelectorAll('.action').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const a = btn.getAttribute('data-action');
          if (a==='task') return goto('tasks');
          if (a==='daily') {
            const ok = await tryDaily(state.userId);
            if(!ok) {
              showWdHint('Daily check-in already claimed today!'); // Added a user-friendly message
              return; // No need to add activity if already claimed, just show hint
            }
            return addBalance(state.userId, DAILY_REWARD, 'Daily Check‑in');
          }
        })
      })

      // Referral copy/share
      els.copyRef.addEventListener('click', async ()=>{
        try{
          await navigator.clipboard.writeText(els.refLink.value);
          await addActivity(state.userId,'Referral link copied');
          showWdHint('Referral link copied!');
        }catch(e){
          console.error("Failed to copy referral link:", e);
          showWdHint('Failed to copy link. Please try manually.');
        }
      });
      els.shareRef.addEventListener('click', async ()=>{
        const url = els.refLink.value;
        const text = `Join PEPE BOT and earn with me! ${url}`;
        try{
          if(navigator.share){
            await navigator.share({ title:'PEPE BOT', text, url });
          } else {
            await navigator.clipboard.writeText(url); // Fallback for older browsers
            showWdHint('Referral link copied to clipboard!'); // Indicate fallback action
          }
          await addActivity(state.userId,'Referral link shared/copied');
        }catch(e){
          console.error("Failed to share/copy referral link:", e);
          showWdHint('Failed to share link. Please copy manually.');
        }
      });

      // Admin
      els.applySet.addEventListener('click', async ()=>{
        const v = parseInt(els.setBalance.value,10);
        if(Number.isFinite(v)){
          if(state.firebaseEnabled && db){
            try{
              await updateDoc(doc(db,'users',String(state.userId)),{ balance: Math.max(0,v) });
              await addActivity(state.userId, `Admin set balance = ${v}`);
              showWdHint(`Balance set to ${v}`);
            }
            catch(err){
              if(isPermissionDenied(err)){
                switchToLocal('Firestore permission denied while admin set.');
                const u = loadLocalUser(state.userId) || await ensureUserLocal(state.userId, state.name);
                u.balance = Math.max(0,v);
                saveLocalUser(state.userId,u);
                await addActivityLocal(state.userId, `Admin set balance = ${v} (fallback)`);
                renderFromLocal(state.userId);
                showWdHint(`Balance set to ${v} (local fallback)`);
              } else {
                showWdHint(err.message || 'Admin set failed');
                throw err;
              }
            }
          } else {
            const u = loadLocalUser(state.userId) || await ensureUserLocal(state.userId, state.name);
            u.balance = Math.max(0,v);
            saveLocalUser(state.userId,u);
            await addActivityLocal(state.userId, `Admin set balance = ${v}`);
            renderFromLocal(state.userId);
            showWdHint(`Balance set to ${v} (local)`);
          }
        }
      });
      els.applyAdjust.addEventListener('click', async ()=>{
        const v = parseInt(els.adjustBalance.value,10);
        if(Number.isFinite(v)) {
          await addBalance(state.userId, v, 'Admin adjust');
          showWdHint(`Balance adjusted by ${v}`);
        }
      });
      els.resetUser.addEventListener('click', async ()=>{
        if(confirm('Are you sure you want to reset your user data? This cannot be undone.')){
          if(state.firebaseEnabled && db){
            try{
              await setDoc(doc(db,'users',String(state.userId)),{
                name: state.name || 'User', balance: 0, createdAt: serverTimestamp(),
                lastDaily: null, referredBy: null, referralBonusClaimed: false, referrals: 0, tasksCompleted: []
              });
              await addActivityFirebase(state.userId,'Admin reset user');
              showWdHint('User data reset successfully!');
            } catch(err){
              if(isPermissionDenied(err)){
                switchToLocal('Firestore permission denied while admin reset.');
                const u = { name: state.name||'User', balance:0, createdAt:Date.now(), lastDaily:null, referredBy:null, referralBonusClaimed:false, referrals:0, tasksCompleted:[], activities:[], withdrawals:[] };
                saveLocalUser(state.userId,u);
                await addActivityLocal(state.userId,'Admin reset user (fallback)');
                renderFromLocal(state.userId);
                showWdHint('User data reset (local fallback)!');
              } else {
                showWdHint(err.message || 'Admin reset failed');
                throw err;
              }
            }
          } else {
            const u = { name: state.name||'User', balance:0, createdAt:Date.now(), lastDaily:null, referredBy:null, referralBonusClaimed:false, referrals:0, tasksCompleted:[], activities:[], withdrawals:[] };
            saveLocalUser(state.userId,u);
            await addActivityLocal(state.userId,'Admin reset user');
            renderFromLocal(state.userId);
            showWdHint('User data reset (local)!');
          }
        }
      });
      els.exportData.addEventListener('click', async ()=>{
        if(state.firebaseEnabled && db){
          try{
            const d = await getDoc(doc(db,'users',String(state.userId)));
            const data = d.data();
            const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a=document.createElement('a'); a.href=url; a.download=`pepebot_${state.userId}.json`; a.click();
            URL.revokeObjectURL(url);
            showWdHint('Data exported as JSON!');
          }
          catch(err){
            if(isPermissionDenied(err)){
              switchToLocal('Firestore permission denied while exporting.');
              const data = loadLocalUser(state.userId) || {};
              const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
              const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`pepebot_${state.userId}.json`; a.click(); URL.revokeObjectURL(url);
              showWdHint('Data exported (local fallback)!');
            } else {
              showWdHint(err.message || 'Export failed');
              throw err;
            }
          }
        } else {
          const data = loadLocalUser(state.userId) || {};
          const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`pepebot_${state.userId}.json`; a.click(); URL.revokeObjectURL(url);
          showWdHint('Data exported (local)!');
        }
      });

      // Tasks claim
      els.taskList.addEventListener('click', async (e)=>{
        const btn = e.target.closest('button[data-task]');
        if(!btn) return;
        const id = btn.getAttribute('data-task');
        if(btn.classList.contains('cursor-not-allowed')) {
          showWdHint('Task already completed!');
          return;
        }
        try {
          await handleTaskClaim(state.userId, id);
          showWdHint('Task claimed successfully!');
        } catch (error) {
          console.error("Task claim failed:", error);
          showWdHint(error.message || 'Failed to claim task.');
        }
      });

      // Withdraw
      els.submitWithdraw.addEventListener('click', async ()=>{
        const amount = parseInt(els.wdAmount.value,10)||0;
        const method = "Binance UID";
        const address = (els.wdAddress.value||'').trim();
        
        // Clear any previous hint before showing a new one
        els.wdHint.classList.remove('opacity-100');
        els.wdHint.classList.add('opacity-0');
        els.wdHint.textContent = ''; // Ensure text is clear quickly

        if(amount < MIN_WITHDRAW){
            showWdHint(`Amount must be ≥ ${MIN_WITHDRAW}`);
            return;
        }
        if(!address){
            showWdHint('Binance UID is required');
            return;
        }
        try{
          if(state.firebaseEnabled && db){
            try{
              await runTransaction(db, async (tx)=>{
                const d = doc(db,'users',String(state.userId));
                const snap = await tx.get(d);
                const bal = snap.data().balance||0;
                if(bal < amount) throw new Error('Insufficient balance');
                tx.update(d,{ balance: bal - amount });
              });
              await addDoc(collection(db,'users',String(state.userId),'withdrawals'),{ amount, method, address, status:'pending', createdAt: serverTimestamp() });
              await addActivity(state.userId, `Withdrawal requested −${amount} coins`);
              els.wdAmount.value=''; els.wdAddress.value='';
              showWdHint('Request submitted. Please wait for approval.');
            } catch(err){
                if(isPermissionDenied(err)){
                    switchToLocal('Firestore permission denied while submitting withdrawal.');
                    return submitWithdrawLocal(amount,method,address);
                } else {
                    showWdHint(err.message || 'Failed to submit withdrawal request');
                    throw err;
                }
            }
          } else {
            return submitWithdrawLocal(amount,method,address);
          }
        } catch(err){ showWdHint(err.message || 'Failed to submit withdrawal request'); }
      });
    }

    async function submitWithdrawLocal(amount, method, address){
      const u = loadLocalUser(state.userId) || await ensureUserLocal(state.userId, state.name);
      if((u.balance||0) < amount) { showWdHint('Insufficient balance'); return; }
      u.balance = (u.balance||0) - amount;
      u.withdrawals = u.withdrawals || [];
      u.withdrawals.push({ amount, method, address, status:'pending', createdAt: Date.now() });
      saveLocalUser(state.userId, u);
      await addActivityLocal(state.userId, `Withdrawal requested −${amount} coins`);
      renderFromLocal(state.userId);
      els.wdAmount.value=''; els.wdAddress.value=''; showWdHint('Request submitted (local mode).');
    }


<script type="module">
    // ... existing code ...

    function showAdminIfAllowed(){
      const currentUserId = state.userId;
      // Use loose comparison to check both string and number formats
      const isAdmin = ADMIN_IDS.some(id => id == currentUserId);
      const isAdminFromQuery = isAdminQuery;

      const allow = isAdminFromQuery || isAdmin;
      if(els.adminPanel) els.adminPanel.classList.toggle('hidden', !allow);
      if(els.adminHint) els.adminHint.textContent = allow ? `UID: ${currentUserId}` : '';
    }

    // ... rest of the code ...
</script>


    
      // --- Debugging Admin Identification ---
      console.log("Admin Check:");
      console.log("  state.userId (from Telegram/Mock):", currentUserId, typeof currentUserId);
      console.log("  parsedUserId (for comparison):", parsedUserId, typeof parsedUserId);
      console.log("  ADMIN_IDS (configured):", ADMIN_IDS);
      console.log("  Is user ID in ADMIN_IDS?", isAdmin);
      console.log("  Is admin query param present (?admin=1)?", isAdminFromQuery);
      // --- End Debugging ---

      const allow = isAdminFromQuery || isAdmin;
      if(els.adminPanel) els.adminPanel.classList.toggle('hidden', !allow);
      if(els.adminHint) els.adminHint.textContent = allow ? `UID: ${currentUserId}` : '';
    }

    // Boot
    els.year.textContent = new Date().getFullYear();
    bindActions();
    initTelegramOrFallback();
    if(els.minWd) els.minWd.textContent = MIN_WITHDRAW;
  </script>

  <!--
  ================= Firestore Security Rules (CRITICAL FOR PRODUCTION WITHOUT FIREBASE AUTH) =================
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      // WARNING:
      // If you are NOT using Firebase Authentication, you CANNOT rely on 'request.auth'.
      // This means that if you want data to be private per Telegram user,
      // you MUST implement a SECURE BACKEND SERVER (e.g., Firebase Cloud Functions)
      // to verify Telegram's initData and then perform Firestore operations on behalf of the user.
      //
      // The rules below rely ONLY on the UID provided in the document path (`{uid}`).
      // THIS IS NOT SECURE BY ITSELF FOR PRODUCTION. A malicious client could simply fake the UID in the request.
      // REAL SECURITY REQUIRES A BACKEND TO VERIFY TELEGRAM INITIATION DATA.
      //
      // For testing/development where security is less critical, these rules will work with the client-side UID.

      match /users/{uid} {
        // Allow read/create/update if the UID in the path matches the UID provided by the client.
        // This is still INSECURE for production without backend validation.
        allow read, create, update: if request.resource.id == uid;

        match /activities/{doc} {
          allow read, create: if request.resource.id == uid;
        }
        match /withdrawals/{doc} {
          allow read, create: if request.resource.id == uid;
          // You might want an admin-only update rule for withdrawal status, e.g.:
          // allow update: if get(/databases/$(database)/documents/users/$(request.resource.id)).data.isAdmin == true;
          // But this would also need backend enforcement.
        }
      }
    }
  }

  NOTE: For a secure production application where user data privacy is required,
  you MUST implement server-side verification of Telegram initData. This backend
  would then perform authenticated writes to Firestore on behalf of the verified user.
  Direct client-side writes to Firestore without strong authentication are NOT recommended.
  -->
</body>
</html>```
